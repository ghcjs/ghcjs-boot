diff --git a/GHC/Integer/GMP/Internals.hs b/GHC/Integer/GMP/Internals.hs
index b80840b..03d9d58 100644
--- a/GHC/Integer/GMP/Internals.hs
+++ b/GHC/Integer/GMP/Internals.hs
@@ -1,6 +1,10 @@
-{-# LANGUAGE NoImplicitPrelude #-}
+{-# LANGUAGE NoImplicitPrelude, CPP, MagicHash #-}
 
+#ifdef __GHCJS__
+module GHC.Integer.GMP.Internals (Integer(S#), gcdInt, gcdInteger, gcdExtInteger, lcmInteger, powInteger, powModInteger, recipModInteger)
+#else
 module GHC.Integer.GMP.Internals (Integer(..), gcdInt, gcdInteger, gcdExtInteger, lcmInteger, powInteger, powModInteger, recipModInteger)
+#endif
     where
 
 import GHC.Integer.Type
diff --git a/GHC/Integer/GMP/Prim.hs b/GHC/Integer/GMP/Prim.hs
index 401855b..9acfddf 100644
--- a/GHC/Integer/GMP/Prim.hs
+++ b/GHC/Integer/GMP/Prim.hs
@@ -221,6 +221,10 @@ foreign import ccall unsafe "hs_integerToWord64"
 #endif
 
 -- used to be primops:
+#ifdef __GHCJS__
+foreign import prim "integer_cmm_integer2Intzh" integer2Int#
+  :: Int# -> ByteArray# -> Int#
+#else
 integer2Int# :: Int# -> ByteArray# -> Int#
 integer2Int# s d = if isTrue# (s ==# 0#)
                        then 0#
@@ -228,6 +232,7 @@ integer2Int# s d = if isTrue# (s ==# 0#)
                             if isTrue# (s <# 0#)
                                then negateInt# v
                                else v
+#endif
 
 integer2Word# :: Int# -> ByteArray# -> Word#
 integer2Word# s d = int2Word# (integer2Int# s d)
diff --git a/GHC/Integer/Logarithms/Internals.hs b/GHC/Integer/Logarithms/Internals.hs
index 59c800a..518fdba 100644
--- a/GHC/Integer/Logarithms/Internals.hs
+++ b/GHC/Integer/Logarithms/Internals.hs
@@ -23,7 +23,7 @@ import GHC.Integer.Type
 
 -- When larger word sizes become common, add support for those,
 -- it is not hard, just tedious.
-#if (WORD_SIZE_IN_BITS != 32) && (WORD_SIZE_IN_BITS != 64)
+#if ((WORD_SIZE_IN_BITS != 32) && (WORD_SIZE_IN_BITS != 64)) || __GHCJS__
 
 -- Less than ideal implementations for strange word sizes
 
diff --git a/GHC/Integer/Type.lhs b/GHC/Integer/Type.lhs
index 6e13eb5..bbc4564 100644
--- a/GHC/Integer/Type.lhs
+++ b/GHC/Integer/Type.lhs
@@ -264,10 +264,18 @@ gcdInteger a b@(S# INT_MINBOUND) = gcdInteger a (toBig b)
 gcdInteger (S# a) (S# b) = S# (gcdInt a b)
 gcdInteger ia@(S# a)  ib@(J# sb b)
  =      if isTrue# (a  ==# 0#) then absInteger ib
-   else if isTrue# (sb ==# 0#) then absInteger ia
-   else                             S# (gcdIntegerInt# absSb b absA)
+#ifdef __GHCJS__
+   else if isTrue# (cmpIntegerInt# sb b 0# ==# 0#)
+          then absInteger ia
+          else S# (gcdIntegerInt# sb b a) -- foreign code deals with negative numbers
+#else
+   else if isTrue# (sb ==# 0#)
+          then absInteger ia
+          else S# (gcdIntegerInt# absSb b absA)
        where !absA  = if isTrue# (a  <# 0#) then negateInt# a  else a
              !absSb = if isTrue# (sb <# 0#) then negateInt# sb else sb
+#endif
+
 gcdInteger ia@(J# _ _) ib@(S# _) = gcdInteger ib ia
 gcdInteger (J# sa a) (J# sb b)
   = case gcdInteger# sa a sb b of (# sg, g #) -> J# sg g
@@ -426,7 +434,13 @@ instance Ord Integer where
 absInteger :: Integer -> Integer
 absInteger (S# INT_MINBOUND) = NEG_INT_MINBOUND
 absInteger n@(S# i)   = if isTrue# (i >=# 0#) then n else S# (negateInt# i)
+#ifdef __GHCJS__
+absInteger n@(J# s d) = if isTrue# (cmpIntegerInt# s d 0# <# 0#)
+                          then negateInteger n
+                          else n
+#else
 absInteger n@(J# s d) = if isTrue# (s >=# 0#) then n else J# (negateInt# s) d
+#endif
 
 {-# NOINLINE signumInteger #-}
 signumInteger :: Integer -> Integer
@@ -479,7 +493,14 @@ timesInteger (J# s1 d1) (J# s2 d2) = case timesInteger# s1 d1 s2 d2 of
 negateInteger :: Integer -> Integer
 negateInteger (S# INT_MINBOUND) = NEG_INT_MINBOUND
 negateInteger (S# i)            = S# (negateInt# i)
+#ifdef __GHCJS__
+negateInteger (J# s d)          = case int2Integer# 0# of
+                                    (# zs, zd #) ->
+                                      case minusInteger# zs zd s d of
+                                        (# s', d' #) -> J# s' d'
+#else
 negateInteger (J# s d)          = J# (negateInt# s) d
+#endif
 \end{code}
 
 
